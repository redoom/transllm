# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-12-01T07:33:38+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, confloat, conint


class ContentBlockType(Enum):
    text = 'text'
    image_url = 'image_url'
    tool_result = 'tool_result'
    reasoning = 'reasoning'
    thinking = 'thinking'
    redacted_thinking = 'redacted_thinking'


class ImageDetailLevel(Enum):
    high = 'high'
    low = 'low'
    auto = 'auto'


class RoleType(Enum):
    system = 'system'
    user = 'user'
    assistant = 'assistant'
    tool = 'tool'


class ResponseRoleType(Enum):
    assistant = 'assistant'
    tool = 'tool'


class Type(Enum):
    """
    Content block type
    """

    text = 'text'
    image_url = 'image_url'
    tool_result = 'tool_result'
    reasoning = 'reasoning'
    thinking = 'thinking'
    redacted_thinking = 'redacted_thinking'


class Detail(Enum):
    """
    Image processing detail level
    """

    high = 'high'
    low = 'low'
    auto = 'auto'


class ImageUrl(BaseModel):
    """
    Image content
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    url: Optional[str] = Field(None, description='Image URL or base64 data')
    detail: Optional[Detail] = Field(None, description='Image processing detail level')


class ToolResult(BaseModel):
    """
    Tool execution result
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    tool_name: Optional[str] = Field(None, description='Tool name')
    result: Optional[Dict[str, Any]] = Field(
        None, description='Tool execution result data'
    )


class Reasoning(BaseModel):
    """
    Reasoning content (thinking mode)
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    content: Optional[str] = Field(None, description='Reasoning text')


class Thinking(BaseModel):
    """
    Thinking content (Anthropic extended thinking)
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    content: Optional[str] = Field(None, description='Thinking text')


class RedactedThinking(BaseModel):
    """
    Redacted thinking content (Anthropic extended thinking)
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    content: Optional[str] = Field(None, description='Redacted thinking text')


class ContentBlock(BaseModel):
    """
    Message content block supporting multiple content types
    """

    type: Type = Field(..., description='Content block type')
    text: Optional[str] = Field(None, description='Text content')
    image_url: Optional[ImageUrl] = Field(None, description='Image content')
    tool_result: Optional[ToolResult] = Field(None, description='Tool execution result')
    reasoning: Optional[Reasoning] = Field(
        None, description='Reasoning content (thinking mode)'
    )
    thinking: Optional[Thinking] = Field(
        None, description='Thinking content (Anthropic extended thinking)'
    )
    redacted_thinking: Optional[RedactedThinking] = Field(
        None, description='Redacted thinking content (Anthropic extended thinking)'
    )
    cache_control: Optional[Dict[str, Any]] = Field(
        None, description='Cache control metadata for prompt caching (Anthropic)'
    )


class Role(Enum):
    """
    Message sender role
    """

    system = 'system'
    user = 'user'
    assistant = 'assistant'
    tool = 'tool'


class ToolDefinition(BaseModel):
    """
    Tool definition
    """

    name: str = Field(..., description='Tool name')
    description: str = Field(..., description='Tool functionality description')
    parameters: Optional[Dict[str, Any]] = Field(
        None, description='JSON Schema format tool parameter definition'
    )
    metadata: Optional[Dict[str, Any]] = Field(None, description='Tool metadata')
    cache_control: Optional[Dict[str, Any]] = Field(
        None, description='Cache control metadata for tool definitions (Anthropic)'
    )


class ToolCall(BaseModel):
    """
    Tool call
    """

    identifier: Optional[str] = Field(None, description='Tool call unique identifier')
    name: str = Field(..., description='Called tool name')
    arguments: Dict[str, Any] = Field(..., description='Tool call arguments')


class GenerationParameters(BaseModel):
    """
    Generation parameters configuration
    """

    temperature: Optional[confloat(ge=0.0, le=2.0)] = Field(
        None, description='Controls output randomness'
    )
    max_tokens: Optional[conint(ge=1)] = Field(
        None, description='Maximum number of tokens to generate'
    )
    max_completion_tokens: Optional[conint(ge=1)] = Field(
        None, description='Maximum tokens for completion (newer API version)'
    )
    top_p: Optional[confloat(ge=0.0, le=1.0)] = Field(
        None, description='Nucleus sampling parameter'
    )
    top_k: Optional[conint(ge=0)] = Field(None, description='Top-K sampling parameter')
    stop_sequences: Optional[List[str]] = Field(None, description='Stop sequences')
    stream: Optional[bool] = Field(None, description='Enable streaming output')
    seed: Optional[int] = Field(None, description='Random seed')
    presence_penalty: Optional[float] = Field(
        None, description='Presence penalty coefficient'
    )
    frequency_penalty: Optional[float] = Field(
        None, description='Frequency penalty coefficient'
    )
    logit_bias: Optional[Dict[str, float]] = Field(
        None,
        description='Modify token probability distribution (maps token IDs to bias values)',
    )
    response_format: Optional[Dict[str, Any]] = Field(
        None, description='Response format specification (e.g., JSON mode, schema)'
    )
    logprobs: Optional[bool] = Field(None, description='Return token log probabilities')
    top_logprobs: Optional[conint(ge=0)] = Field(
        None, description='Number of log probabilities to return'
    )
    n: Optional[conint(ge=1)] = Field(
        None, description='Number of chat completion choices to generate'
    )
    stream_options: Optional[Dict[str, Any]] = Field(
        None, description='Streaming options (e.g., include_usage)'
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Generation parameters metadata'
    )


class GroundingAttribution(BaseModel):
    """
    Grounding attribution for responses with source citations
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    content_index: Optional[int] = Field(None, description='Content block index')
    model_decision: Optional[str] = Field(None, description='Model decision text')
    grounding_chunk_indices: Optional[List[int]] = Field(
        None, description='Indices of grounding chunks'
    )
    source_chunk_indices: Optional[List[int]] = Field(
        None, description='Indices of source chunks'
    )


class ToolChoice(Enum):
    """
    Tool selection strategy
    """

    auto = 'auto'
    none = 'none'
    any = 'any'


class UsageStatistics(BaseModel):
    """
    Token usage statistics
    """

    prompt_tokens: Optional[int] = Field(None, description='Input token count')
    completion_tokens: Optional[int] = Field(None, description='Output token count')
    total_tokens: int = Field(..., description='Total token count')
    input_tokens: Optional[int] = Field(None, description='Input token count (alias)')
    output_tokens: Optional[int] = Field(None, description='Output token count (alias)')
    cached_tokens: Optional[int] = Field(None, description='Cached token count')
    cache_creation_input_tokens: Optional[int] = Field(
        None, description='Input tokens used to create cache (Anthropic)'
    )
    cache_read_input_tokens: Optional[int] = Field(
        None, description='Input tokens read from cache (Anthropic)'
    )
    reasoning_tokens: Optional[int] = Field(
        None,
        description='Tokens used for reasoning/thinking (extended thinking models)',
    )


class Role1(Enum):
    """
    Message sender role
    """

    assistant = 'assistant'
    tool = 'tool'


class ResponseMessage(BaseModel):
    """
    Response message
    """

    role: Role1 = Field(..., description='Message sender role')
    content: Union[str, List[ContentBlock]] = Field(..., description='Message content')
    tool_calls: Optional[List[ToolCall]] = Field(None, description='Tool calls list')
    reasoning_content: Optional[str] = Field(
        None, description='Reasoning content from reasoning models (e.g., OpenAI o1)'
    )
    thinking_blocks: Optional[List[Dict[str, Any]]] = Field(
        None, description='Structured thinking blocks from reasoning models'
    )
    identifier: Optional[str] = Field(None, description='Message unique identifier')


class FinishReason(Enum):
    stop = 'stop'
    length = 'length'
    content_filter = 'content_filter'
    tool_calls = 'tool_calls'
    safety = 'safety'
    recitation = 'recitation'
    other = 'other'


class FinishReason1(Enum):
    """
    Completion reason
    """

    stop = 'stop'
    length = 'length'
    content_filter = 'content_filter'
    tool_calls = 'tool_calls'
    safety = 'safety'
    recitation = 'recitation'
    other = 'other'


class Choice(BaseModel):
    """
    Response choice
    """

    message: ResponseMessage
    index: int = Field(..., description='Choice index')
    finish_reason: Optional[FinishReason1] = Field(
        None, description='Completion reason'
    )
    logprobs: Optional[Dict[str, Any]] = Field(
        None, description='Log probability information'
    )


class CoreResponse(BaseModel):
    """
    Core response model (brand-neutral)
    """

    id: Optional[str] = Field(None, description='Response unique identifier')
    object: Optional[str] = Field('core.response', description='Object type')
    created: Optional[int] = Field(
        None, description='Creation timestamp (Unix timestamp)'
    )
    model: Optional[str] = Field(None, description='Used model identifier')
    choices: List[Choice] = Field(..., description='Response choices list')
    usage: Optional[UsageStatistics] = None
    grounding_attributions: Optional[List[GroundingAttribution]] = Field(
        None, description='Grounding attributions for citations'
    )
    metadata: Optional[Dict[str, Any]] = Field(None, description='Response metadata')


class StreamEventType(Enum):
    content_delta = 'content_delta'
    tool_call_delta = 'tool_call_delta'
    content_finish = 'content_finish'
    stream_end = 'stream_end'
    error = 'error'
    metadata_update = 'metadata_update'


class ToolCallDelta(BaseModel):
    """
    Tool call delta for streaming
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    name: Optional[str] = None
    arguments_delta: Optional[str] = None
    identifier: Optional[str] = None


class Error(BaseModel):
    """
    Error information
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    code: Optional[str] = None
    message: Optional[str] = None
    details: Optional[Dict[str, Any]] = None


class StreamEvent(BaseModel):
    """
    Streaming event
    """

    type: StreamEventType
    sequence_id: int = Field(
        ..., description='Event sequence number (ensures ordering)'
    )
    timestamp: float = Field(..., description='Event timestamp')
    content_delta: Optional[str] = Field(None, description='Incremental content')
    tool_call_delta: Optional[ToolCallDelta] = None
    tool_call: Optional[List[ToolCall]] = Field(
        None, description='Complete tool calls (when tool call is finished)'
    )
    finish_reason: Optional[str] = Field(None, description='Completion reason')
    content_index: Optional[int] = Field(None, description='Content block index')
    error: Optional[Error] = Field(None, description='Error information')
    metadata: Optional[Dict[str, Any]] = Field(None, description='Event metadata')


class ErrorType(Enum):
    validation_error = 'validation_error'
    not_supported = 'not_supported'
    conversion_error = 'conversion_error'
    internal_error = 'internal_error'


class Type1(Enum):
    """
    Error type
    """

    validation_error = 'validation_error'
    not_supported = 'not_supported'
    conversion_error = 'conversion_error'
    internal_error = 'internal_error'


class ErrorDetail(BaseModel):
    """
    Error detail
    """

    code: str = Field(..., description='Error code')
    message: str = Field(..., description='Error message')
    type: Optional[Type1] = Field(None, description='Error type')
    details: Optional[Dict[str, Any]] = Field(
        None, description='Detailed error information'
    )


class ErrorResponse(BaseModel):
    """
    Error response
    """

    error: ErrorDetail
    request_id: Optional[str] = Field(None, description='Request ID')
    timestamp: Optional[float] = Field(None, description='Error occurrence timestamp')


class ProviderIdentifier(Enum):
    """
    Supported LLM providers
    """

    openai = 'openai'
    anthropic = 'anthropic'
    gemini = 'gemini'
    azure_openai = 'azure_openai'
    aws_bedrock = 'aws_bedrock'
    google_vertex_ai = 'google_vertex_ai'
    cohere = 'cohere'
    huggingface = 'huggingface'
    vllm = 'vllm'
    nvidia_nim = 'nvidia_nim'
    together_ai = 'together_ai'
    fireworks_ai = 'fireworks_ai'
    mistral = 'mistral'
    groq = 'groq'


class Message(BaseModel):
    """
    Conversation message model
    """

    role: Role = Field(..., description='Message sender role')
    content: Union[str, List[ContentBlock]] = Field(..., description='Message content')
    metadata: Optional[Dict[str, Any]] = Field(None, description='Additional metadata')
    tool_calls: Optional[List[ToolCall]] = Field(None, description='Tool calls list')
    identifier: Optional[str] = Field(None, description='Message unique identifier')
    cache_control: Optional[Dict[str, Any]] = Field(
        None, description='Cache control metadata for message-level caching (Anthropic)'
    )


class CoreRequest(BaseModel):
    """
    Core request model (brand-neutral)
    """

    model: str = Field(..., description='Model identifier')
    messages: List[Message] = Field(..., description='Conversation messages list')
    tools: Optional[List[ToolDefinition]] = Field(
        None, description='Available tool definitions list'
    )
    tool_choice: Optional[Union[ToolChoice, Dict[str, Any]]] = Field(
        None, description='Tool selection strategy'
    )
    parallel_tool_calls: Optional[bool] = Field(
        None, description='Allow parallel execution of multiple tools'
    )
    system_instruction: Optional[str] = Field(
        None, description='System-level instruction (separate from messages list)'
    )
    generation_params: Optional[GenerationParameters] = None
    metadata: Optional[Dict[str, Any]] = Field(None, description='Request metadata')
